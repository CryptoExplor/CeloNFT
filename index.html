<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Correct Viewport for full responsiveness -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Celo NFT Mint</title>
  <meta name="description" content="Mint a free Celo NFT that shows the live CELO price!" />
  <meta property="og:title" content="CELO NFT Mint" />
  <meta property="og:description" content="Mint a free, unique NFT capturing the live CELO price on the moment of transaction." />
  
  <!-- **ACTION REQUIRED**: Replace the href with the URL of your actual app logo (e.g., a 64x64 transparent PNG). -->
  <link rel="icon" type="image/png" href="https://assets-global.website-files.com/64b589417d470659a8508e6e/65f97cc1c34a2608c704259b_celo.png">
  <!-- *** END: ADDED METADATA *** -->

  <!-- Google Fonts for NFT typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Monoton&family=Orbitron&family=Roboto+Mono&family=VT323&display=swap" rel="stylesheet">

  <!-- Farcaster Mini App Metadata (UNCHANGED) -->
  <meta name="fc:miniapp" content='{
    "version":"1",
    "imageUrl":"https://celo-nft-phi.vercel.app/image.png",
    "button":{
      "title":"Celo NFT",
      "action":{
        "type":"launch_frame",
        "name":"MINT",
        "url":"https://celo-nft-phi.vercel.app",
        "splashImageUrl":"https://celo-nft-phi.vercel.app/splash.png",
        "splashBackgroundColor":"#111111"
      }
    }
  }' />

  <style>
    body {
      margin: 0;
      background: #111;
      color: white;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      /* Keep body padding for spacing around the edges */
      padding: 5px 5px; 
      box-sizing: border-box;
      text-align: center; 
    }
    .tradingview-widget-container {
      width: 100%;
      max-width: 390px;
      height: 300px;
      border: 1px solid #333;
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 16px;
    }
    #celo-chart {
        height: 100%;
        width: 100%;
    }
    .status-box {
      font-size: 1rem;
      padding: 8px 12px;
      border-radius: 8px;
      text-align: center;
      width: 90%;
      max-width: 320px;
      margin-bottom: 12px;
    }
    .status-info { background: #1e40af; }
    .status-warning { background: #b45309; }
    .status-success { background: #16a34a; } 
    .status-error { background: #b91c1c; }
    .action-button {
      padding: 1rem 2rem;
      font-size: 1.2rem;
      font-weight: bold;
      color: #0f0f0f;
      background: linear-gradient(90deg, #49dfb5, #7dd3fc);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      margin-bottom: 12px;
      box-shadow: 0 2px 8px #0008;
      transition: background 0.2s, color 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .action-button:disabled {
      background: #888 !important;
      color: #444;
      cursor: not-allowed;
    }
    .preview-button {
        background: linear-gradient(90deg, #f97316, #fcd34d); /* Orange/Yellow gradient */
        font-size: 1rem;
        padding: 0.75rem 1.5rem;
    }
    .addresses-box {
      background: #131417;
      font-size: 0.9rem;
      padding: 6px 10px;
      border-radius: 7px;
      margin-bottom: 12px;
      width: 85%;
      max-width: 330px;
      word-break: break-all;
      color: #c3cfe8;
      text-align: center;
    }
    footer {
      margin-top: auto;
      display: flex;
      gap: 24px;
      padding-bottom: 12px;
    }
    footer svg {
      fill: #fafafa;
      width: 28px;
      height: 28px;
    }
    .hidden { display:none; }
    
    /* FIX: Implement responsive, non-cropping scaling */
    #nft-preview-container {
        margin-top: 10px;
        margin-bottom: 10px;
        width: 100%; 
        max-width: 390px; 
        background: #000;
        border: 2px solid #49dfb5;
        border-radius: 10px;
        display: flex;
        justify-content: center; 
        align-items: center;
        padding: 0; 
        position: relative; 
        /* allow vertical growth up to viewport, then scroll */
        max-height: 60vh;
        overflow: hidden;      /* <-- Changed from auto to hidden to remove scroll */
        box-sizing: border-box;
    }

    /* Make inline SVG scale naturally without distortion */
    #nft-preview-container svg {
      display: block;
      width: 100%;    /* scale horizontally up to container width */
      height: auto;   /* preserve aspect ratio */
      max-height: 60vh; /* prevents it pushing page off-screen */
      margin: 0 auto;
      box-sizing: border-box;
    }

    /* Fallback for image-type tokenURI (data:image/...), if present */
    #nft-preview-container img {
      display: block;
      width: 100%;
      height: auto;
      max-height: 60vh;
      margin: 0 auto;
    }
    /* --- START NEW SPARKLE CSS (UNCHANGED) --- */
    .sparkles::before {
      content: "";
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: radial-gradient(circle, white 2px, transparent 2px);
      background-size: 20px 20px;
      pointer-events: none;
      opacity: 0.7;
      animation: sparkle 6s linear infinite; 
      z-index: 10; 
    }

    @keyframes sparkle {
      0% { background-position: 0 0; opacity: 0.6; }
      50% { background-position: 10px 10px; opacity: 1; }
      100% { background-position: 0 0; opacity: 0.6; }
    }

    .common.sparkles::before {
      background: radial-gradient(circle, #bbb 1.5px, transparent 2px); 
      animation-duration: 6s;
    }
    .rare.sparkles::before {
      background: radial-gradient(circle, #2196f3 2.5px, transparent 2px); 
      animation-duration: 4s;
    }
    .legendary.sparkles::before {
      background: radial-gradient(circle, gold 3.5px, transparent 2px);
      animation-duration: 2s; 
    }
    .mythic.sparkles::before {
      background: radial-gradient(circle, crimson 4px, transparent 2px);
      animation-duration: 1.5s; 
    }
    /* --- END NEW SPARKLE CSS --- */
    /* Spinner CSS for Loading Indicator (UNCHANGED) */
    .spinner {
      border: 2px solid #fff3;
      border-top: 2px solid #fff;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: inline-block;
      animation: spin 0.6s linear infinite;
    }
    @keyframes spin { 100% { transform: rotate(360deg); } }
  </style>
</head>
<body>

  <!-- 1. Live CELOUSD chart -->
  <div class="tradingview-widget-container" role="img" aria-label="Live CELO Price Chart">
    <div id="celo-chart"></div>
    <script src="https://s3.tradingview.com/tv.js"></script>
    <script>
      new TradingView.widget({
        autosize: true,
        symbol: "BINANCE:CELOUSDT",
        interval: "60",
        theme: "dark",
        style: "1",
        hide_top_toolbar: true,
        withdateranges: false,
        toolbar_bg: "#1f1f1f",
        locale: "en",
        enable_publishing: false,
        allow_symbol_change: false,
        container_id: "celo-chart"
      });
    </script>
  </div>

  <h1>Mint Your Celo Price NFT</h1>

  <!-- User Address -->
  <div id="userAddressBox" class="addresses-box hidden"></div>
  <!-- Total Minted - Initial content will be updated by JS -->
  <div id="totalSupply" class="status-box status-warning">
    <!-- JS will inject spinner here -->
  </div>
  <!-- Mint Button -->
  <button class="action-button" id="mintBtn">MINT</button>
  <!-- Preview Button (hidden until mint success) -->
  <button class="action-button preview-button hidden" id="previewBtn">Preview NFT</button>

  <!-- Status Box with Accessibility Attribute -->
  <div id="statusBox" class="status-box" aria-live="polite"></div>

  <!-- NFT SVG Preview -->
  <div id="nft-preview-container" class="hidden">
      <!-- SVG will be injected here -->
  </div>

  <!-- Footer -->
  <footer>
    <a href="https://farcaster.xyz/dare1.eth" target="_blank" aria-label="Farcaster">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8z"/><path d="M12 7c-2.757 0-5 2.243-5 5s2.243 5 5 5 5-2.243 5-5-2.243-5-5-5zm0 8c-1.654 0-3-1.346-3-3s1.346-3 3-3 3 1.346 3 3-1.346 3-3 3z"/></svg>
    </a>
    <a href="https://x.com/kumar14700" target="_blank" aria-label="Twitter">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 16 16"><path d="M12.6.75h2.454l-5.36 6.142L16 15.25h-4.937l-3.867-5.07-4.425 5.07H.316l5.733-6.57L0 .75h5.063l3.495 4.633L12.601.75Zm-.86 13.028h1.36L4.323 2.145H2.865l8.875 11.633Z"/></svg>
    </a>
  </footer>

  <!-- Farcaster SDK (UNCHANGED) -->
  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    sdk.actions.ready({ disableNativeGestures: true });
  </script>

  <!-- Wagmi + Celo Logic -->
  <script type="module">
    import {
      createConfig,
      connect,
      writeContract,
      readContract,
      http
    } from 'https://esm.sh/@wagmi/core';
    import { celo } from 'https://esm.sh/@wagmi/core/chains';
    import { farcasterMiniApp } from 'https://esm.sh/@farcaster/miniapp-wagmi-connector';
    import { parseEther } from 'https://esm.sh/viem';
    
    // Configuration: Change this if your contract function name is different
    const MAX_SUPPLY_FUNCTION_NAME = 'maxSupply'; // Kept for consistency, even if maxSupply is no longer used in the contract

    const statusBox    = document.getElementById('statusBox');
    const supplyBox    = document.getElementById('totalSupply');
    const mintBtn      = document.getElementById('mintBtn');
    const previewBtn   = document.getElementById('previewBtn');
    const userAddrBox  = document.getElementById('userAddressBox');
    const previewContainer = document.getElementById('nft-preview-container');
    // Array of all possible rarity classes for quick removal (4 Tiers: Common, Rare, Legendary, Mythic)
    const ALL_RARITY_CLASSES = ["common", "rare", "legendary", "mythic"];

    let MAX_SUPPLY = 0; // Dynamic supply limit, 0 means unlimited/unknown
    let lastMintedTokenId = null;
    let contractAddress = null;
    let mintPriceWei = 0n; // Use BigInt for wei values

    function setStatus(msg, type = 'info') {
      // Clear all previous content, including DOM elements used for links
      statusBox.innerHTML = '';
      
      // Add emoji indicators based on type
      let icon = '';
      if (type === 'success') icon = '✅ ';
      else if (type === 'error') icon = '❌ ';
      else if (type === 'warning') icon = '⚠️ ';
      else icon = 'ℹ️ ';
      
      statusBox.className = `status-box status-${type}`;
      statusBox.insertAdjacentText('afterbegin', icon + msg);
    }
    
    function showAddress(addr) {
      const shortAddr = `${addr.slice(0, 6)}...${addr.slice(-4)}`;
      userAddrBox.textContent = `Your address: ${shortAddr}`;
      userAddrBox.classList.remove('hidden');
    }

    // --- Price fetching function ---
    async function fetchCeloPrice() {
      try {
        const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=celo&vs_currencies=usd');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        // Check if data structure is as expected
        if (!data || !data.celo || !data.celo.usd) {
             throw new Error("Invalid response structure from CoinGecko.");
        }
        const price = data.celo.usd;
        return price;
      } catch (e) {
        console.error("Failed to fetch CELO price:", e);
        throw new Error("Failed to fetch CELO price. Please try again.");
      }
    }

    // Setup wagmi config for Celo
    const config = createConfig({
      chains: [celo],
      transports: { [celo.id]: http() }
    });

    let contractDetails;

    // Helper function to adjust injected SVG attributes for responsive scaling
    function adjustInjectedSvg(container) {
      const svg = container.querySelector('svg');
      if (svg) {
        // If no viewBox but width/height exist, create a viewBox from them
        if (!svg.hasAttribute('viewBox')) {
          const w = svg.getAttribute('width');
          const h = svg.getAttribute('height');
          if (w && h) {
            // parseFloat to handle "400px" etc.
            const W = parseFloat(w);
            const H = parseFloat(h);
            if (!isNaN(W) && !isNaN(H) && W > 0 && H > 0) {
              svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
            }
          }
        }

        // Preserve aspect ratio so nothing gets cropped
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

        // Let CSS control the sizing (remove inline width/height)
        svg.removeAttribute('width');
        svg.removeAttribute('height');

        // Ensure CSS max-height will work
        svg.style.width = '100%';
        svg.style.height = 'auto';
        svg.style.maxHeight = '60vh';
        svg.style.display = 'block';
      } else {
        // If metadata.image was a raster (PNG/JPEG) injected as <img>, style it
        const img = container.querySelector('img');
        if (img) {
          img.style.width = '100%';
          img.style.height = 'auto';
          img.style.maxHeight = '60vh';
          img.style.display = 'block';
        }
      }

      // We are removing the scroll, so only set max-height
      container.style.maxHeight = '60vh';
    }

    // *** REMOVED getLatestTokenIdByAddress: NOT SUPPORTED BY CONTRACT ***
    
    (async () => {
      let address;
      let chainId;
      
      // Connect wallet
      try {
        const conn = await connect(config, { connector: farcasterMiniApp() });
        address = conn.accounts[0];
        chainId = conn.chainId;
        showAddress(address);
      } catch (e) { setStatus("Wallet connect failed.", 'error'); console.error(e); }

      // 2. Network Guard
      if (chainId !== celo.id) {
          setStatus("Please switch to Celo Mainnet.", 'warning');
          mintBtn.disabled = true;
          mintBtn.title = "Switch to Celo Mainnet to mint.";
          return;
      } else {
          mintBtn.title = ""; 
      }

      // 3. Load contract JSON
      try {
        contractDetails = await fetch('./contract.json').then(r => r.json());
        contractAddress = contractDetails.address;
      } catch (e) { 
        setStatus("Missing contract details. Ensure 'contract.json' is deployed.", 'error'); 
        console.error(e); 
        mintBtn.disabled = true; 
        return;
      }

      if(!contractDetails || !address) {
          mintBtn.disabled = true;
          return;
      }
      
      // 4. Fetch MAX_SUPPLY & MINT_PRICE dynamically
      try {
          const [max, price] = await Promise.all([
              // We keep reading maxSupply for completeness, but your contract no longer uses it for limits
              readContract(config, {
                  address: contractDetails.address,
                  abi: contractDetails.abi,
                  functionName: MAX_SUPPLY_FUNCTION_NAME
              }),
              readContract(config, {
                  address: contractDetails.address,
                  abi: contractDetails.abi,
                  functionName: 'mintPrice'
              })
          ]);
          // Note: Max supply is likely not used for limiting anymore
          MAX_SUPPLY = Number(max);
          mintPriceWei = BigInt(price);
          
          // Update button label with price
          if (mintPriceWei > 0n) {
             const celoPrice = Number(mintPriceWei) / 1e18;
             mintBtn.innerText = `MINT (${celoPrice.toFixed(4)} CELO})`;
          }

      } catch (e) {
          setStatus(`Could not read contract settings. Assuming unlimited/free.`, 'warning');
          MAX_SUPPLY = 0; // 0 means unlimited/unknown for this logic
          mintPriceWei = 0n;
          console.warn(`Failed to read contract settings.`, e);
      }

      // 5. Fetch totalSupply
      await updateSupply(true);

      // 6. Initial Load Logic: Use localStorage as the only source for the user's last minted ID
      // This is necessary because the contract lacks a token-listing function.
      const localId = localStorage.getItem("lastMintedTokenId");
      if (localId && Number(localId) > 0) {
          lastMintedTokenId = Number(localId);
          previewBtn.innerText = `Preview NFT #${lastMintedTokenId}`;
          previewBtn.classList.remove('hidden');
      }
    })();


    // Function to update the total supply display and check for sold out status
    async function updateSupply(initialLoad = false) {
        if (initialLoad) {
             supplyBox.innerHTML = '<span class="spinner"></span> Loading supply…';
        }
       
        try {
            const total = await readContract(config, {
                address: contractDetails.address,
                abi: contractDetails.abi,
                functionName: 'totalSupply'
            });
            const totalNumber = Number(total);

            // Check if MAX_SUPPLY is defined (non-zero)
            if (MAX_SUPPLY > 0) {
                supplyBox.textContent = `Minted: ${totalNumber} / ${MAX_SUPPLY}`;

                // Disable mint button if sold out
                if (totalNumber >= MAX_SUPPLY) {
                    mintBtn.disabled = true;
                    mintBtn.innerText = 'SOLD OUT';
                    mintBtn.title = 'The maximum supply has been reached.';
                    supplyBox.className = `status-box status-error`;
                    if (!initialLoad) {
                         setStatus(`⚠️ All ${MAX_SUPPLY} NFTs have been minted!`, 'warning');
                    }
                } else if (!initialLoad && mintBtn.innerText === 'SOLD OUT') {
                    // Restore active state if it was previously sold out but updated
                    mintBtn.disabled = false;
                    const celoPrice = Number(mintPriceWei) / 1e18;
                    mintBtn.innerText = mintPriceWei > 0n ? `MINT (${celoPrice.toFixed(4)} CELO)` : 'MINT';
                    mintBtn.title = '';
                    supplyBox.className = `status-box status-warning`;
                }
            } else {
                 // Display total minted only if max supply is not set/unknown
                 supplyBox.textContent = `Total Minted: ${totalNumber}`;
                 supplyBox.className = `status-box status-info`;
                 mintBtn.disabled = false;
                 const celoPrice = Number(mintPriceWei) / 1e18;
                 mintBtn.innerText = mintPriceWei > 0n ? `MINT (${celoPrice.toFixed(4)} CELO)` : 'MINT';
            }

            // Return the total number read from the contract
            return totalNumber; 
        } catch (e) {
            supplyBox.textContent = 'Total Minted: N/A';
            console.error(e);
            return 0;
        }
    }


    // Function to fetch and display the NFT SVG
    async function previewNft(tokenId) {
        if (!contractDetails) return;
        
        previewBtn.disabled = true;
        previewBtn.innerHTML = '<span class="spinner"></span> Loading Preview…';
        previewContainer.classList.add('hidden');
        previewContainer.innerHTML = ''; // Clear previous SVG
        
        // Remove old sparkle and rarity classes before starting
        previewContainer.classList.remove("sparkles", ...ALL_RARITY_CLASSES); 

        try {
            // 1. Read the tokenURI from the contract
            const tokenURI = await readContract(config, {
                address: contractAddress,
                abi: contractDetails.abi,
                functionName: 'tokenURI',
                args: [BigInt(tokenId)] 
            });

            // 2. Decode the base64 JSON part
            const base64Json = tokenURI.split(',')[1];
            if (!base64Json) throw new Error("Invalid tokenURI format.");

            // FIX: Use decodeURIComponent before atob for robust Base64 decoding, 
            const jsonString = atob(decodeURIComponent(base64Json));
            const metadata = JSON.parse(jsonString);
            
            // 3. Decode the base64 SVG part
            const base64Svg = metadata.image.split(',')[1];
            if (!base64Svg) throw new Error("Invalid image data format.");

            // FIX: Apply the same robust decoding logic to the image (SVG) content.
            let svgString = atob(decodeURIComponent(base64Svg));
            
            // Security: Sanitize injected SVG
            const safeSvg = svgString.replace(/<script.*?>.*?<\/script>/g, '');

            // 4. Inject the safe SVG into the container
            previewContainer.innerHTML = safeSvg;
            previewContainer.classList.remove('hidden');

            // NEW: adjust the injected SVG so it scales correctly
            adjustInjectedSvg(previewContainer);
            
            // 5. Apply Sparkle based on Rarity
            let rarityText = "Common"; // Default
            let priceText = "N/A";

            if (metadata.attributes) {
                const rarityAttr = metadata.attributes.find(attr => attr.trait_type === 'Rarity');
                const priceAttr = metadata.attributes.find(attr => attr.trait_type === 'CELO Price Snapshot');
                
                if (rarityAttr) {
                    rarityText = rarityAttr.value;
                }
                if (priceAttr) priceText = priceAttr.value;
            }
            
            // --- Apply NEW Sparkle Logic ---
            // 1. Ensure base sparkle class is always present
            previewContainer.classList.add("sparkles"); 
            
            // 2. Add the specific new rarity class (lowercase)
            const rarityClassLower = rarityText.toLowerCase();
            previewContainer.classList.add(rarityClassLower); 
            // --- End NEW Sparkle Logic ---

            const buttonLabel = `Preview NFT #${tokenId} (${rarityText} / $${priceText})`;
            previewBtn.innerText = buttonLabel;

        } catch (e) {
            // Error handling shows the exact error from the screenshot
            setStatus("Failed to load NFT preview. Check console for details.", 'error'); 
            previewBtn.innerText = 'Preview NFT Error';
            console.error("NFT Preview Error:", e); // Enhanced console logging
            // Clear preview on error
            previewContainer.classList.add('hidden');
        } finally {
            previewBtn.disabled = false;
        }
    }

    // Minting Handler
    mintBtn.addEventListener('click', async () => {
      if (!contractDetails) {
          setStatus("Contract details are missing. Cannot mint.", 'error');
          return;
      }
      
      // Pre-check for sold out
      if (mintBtn.disabled && mintBtn.innerText === 'SOLD OUT') {
          setStatus("This NFT drop is sold out.", 'warning');
          return;
      }


      // Hide preview button and container before minting
      previewBtn.classList.add('hidden');
      previewContainer.classList.add('hidden');
      // Remove all sparkle/rarity classes
      previewContainer.classList.remove("sparkles", ...ALL_RARITY_CLASSES); 

      // Loading Indicator
      mintBtn.disabled = true;
      mintBtn.innerHTML = '<span class="spinner"></span> Minting…';
      lastMintedTokenId = null;

      try {
        const { address, abi } = contractDetails;
        
        // 1. Fetch CELO price
        const price = await fetchCeloPrice();
        
        // 2. Prepare price for contract (uint128, x10000 for decimals)
        // e.g., $0.6543 -> 6543
        const priceForContract = Math.floor(price * 10000);

        // 3. Mint with price only
        const hash = await writeContract(config, {
          address,
          abi,
          functionName: 'mint',
          // ONLY passing the price (uint128)
          args: [priceForContract], 
          value: parseEther('0') // Assuming a free mint
        });
        
        // 4. *** REVISED RELIABLE STEP ***: Fetch the NEW totalSupply.
        // Since the contract increments totalSupply before minting, the new totalSupply
        // will be the ID of the token just minted.
        const newSupply = await updateSupply();
        lastMintedTokenId = Number(newSupply);
        
        // 5. Store in Local Storage
        localStorage.setItem("lastMintedTokenId", lastMintedTokenId);

        // 6. Update Status and Links
        setStatus("Mint Successful. ", 'success'); 
        
        if (!contractAddress) {
            setStatus("Mint Successful, but contract address is unknown.", 'success');
        } else {
            const celoscanTokenUrl = `https://celoscan.io/token/${contractAddress}?a=${lastMintedTokenId}`;
            const celoscanTxUrl = `https://celoscan.io/tx/${hash}`;
    
            // Create View Tx Link
            const txLink = document.createElement("a");
            txLink.href = celoscanTxUrl;
            txLink.target = "_blank";
            txLink.textContent = "View Tx";
            txLink.style.cssText = "color:#fff;text-decoration:underline";
            
            // Create View on Celoscan Link
            const tokenLink = document.createElement("a");
            tokenLink.href = celoscanTokenUrl;
            tokenLink.target = "_blank";
            tokenLink.textContent = "View on Celoscan";
            tokenLink.style.cssText = "color:#fff;text-decoration:underline";
            
            // Append elements to statusBox
            statusBox.appendChild(txLink);
            statusBox.insertAdjacentText('beforeend', ' | ');
            statusBox.appendChild(tokenLink);
        }
        
        // 7. Preview Auto-Load
        previewBtn.classList.remove('hidden');
        await previewNft(lastMintedTokenId);

      } catch (e) {
        // Use e.shortMessage for clearer error display from Wagmi/Viem
        setStatus(e.shortMessage || "Mint failed.", 'error'); 
        console.error("Mint Error:", e);
        
        // Reset preview button state on failure
        previewBtn.classList.add('hidden');
        previewContainer.classList.add('hidden');
        previewContainer.classList.remove("sparkles", ...ALL_RARITY_CLASSES);
        lastMintedTokenId = null; 
        
        // Restore mint button if it wasn't sold out before failure
        if (mintBtn.innerText !== 'SOLD OUT') {
             mintBtn.disabled = false;
             const celoPrice = Number(mintPriceWei) / 1e18;
             mintBtn.innerText = mintPriceWei > 0n ? `MINT (${celoPrice.toFixed(4)} CELO)` : 'MINT';
        }

      } finally {
        // Only restore 'MINT' text if it's not sold out
        if (mintBtn.innerText !== 'SOLD OUT') {
             mintBtn.disabled = false;
             const celoPrice = Number(mintPriceWei) / 1e18;
             mintBtn.innerText = mintPriceWei > 0n ? `MINT (${celoPrice.toFixed(4)} CELO)` : 'MINT';
        }
      }
    });

    // Preview Handler 
    previewBtn.addEventListener('click', async () => {
        if (lastMintedTokenId !== null) {
            await previewNft(lastMintedTokenId);
        } else {
            setStatus("No token ID to preview. Please mint first.", 'warning');
        }
    });

  </script>
</body>
</html>
