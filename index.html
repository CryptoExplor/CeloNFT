<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Celo NFT Mint</title>
  <meta name="description" content="Mint a free Celo NFT that shows the live CELO price!" />
  <meta property="og:title" content="CELO NFT Mint" />
  <meta property="og:description" content="Mint a free, unique NFT capturing the live CELO price on the moment of transaction." />
  
  <link rel="icon" type="image/png" href="https://assets-global.website-files.com/64b589417d470659a8508e6e/65f97cc1c34a2608c704259b_celo.png">

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Monoton&family=Orbitron&family=Roboto+Mono&family=VT323&display=swap" rel="stylesheet">

  <!-- Farcaster Mini App Metadata -->
  <meta name="fc:miniapp" content='{
    "version":"1",
    "imageUrl":"https://celo-nft-phi.vercel.app/image.png",
    "button":{
      "title":"Celo NFT",
      "action":{
        "type":"launch_miniapp",
        "name":"MINT",
        "url":"https://celo-nft-phi.vercel.app",
        "splashImageUrl":"https://celo-nft-phi.vercel.app/splash.png",
        "splashBackgroundColor":"#111111"
      }
    }
  }' />

  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      margin: 0;
      background: #111;
      color: white;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 5px 5px; 
      text-align: center; 
    }
    
    .tradingview-widget-container {
      width: 100%;
      max-width: 390px;
      height: 300px;
      border: 1px solid #333;
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 16px;
    }
    
    #celo-chart {
      height: 100%;
      width: 100%;
    }
    
    h1 {
      font-size: 1.5rem;
      margin: 10px 0;
    }
    
    .status-box {
      font-size: 1rem;
      padding: 8px 12px;
      border-radius: 8px;
      text-align: center;
      width: 90%;
      max-width: 320px;
      margin-bottom: 12px;
      word-wrap: break-word;
    }
    
    .status-info { background: #1e40af; }
    .status-warning { background: #b45309; }
    .status-success { background: #16a34a; } 
    .status-error { background: #b91c1c; }
    
    .action-button {
      padding: 1rem 2rem;
      font-size: 1.2rem;
      font-weight: bold;
      color: #0f0f0f;
      background: linear-gradient(90deg, #49dfb5, #7dd3fc);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      margin-bottom: 12px;
      box-shadow: 0 2px 8px #0008;
      transition: background 0.2s, color 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-family: 'Orbitron', sans-serif;
    }
    
    .action-button:hover:not(:disabled) {
      opacity: 0.9;
    }
    
    .action-button:disabled {
      background: #888 !important;
      color: #444;
      cursor: not-allowed;
    }
    
    .preview-button {
      background: linear-gradient(90deg, #f97316, #fcd34d);
      font-size: 1rem;
      padding: 0.75rem 1.5rem;
    }
    
    .addresses-box {
      background: #131417;
      font-size: 0.9rem;
      padding: 6px 10px;
      border-radius: 7px;
      margin-bottom: 12px;
      width: 85%;
      max-width: 330px;
      word-break: break-all;
      color: #c3cfe8;
      text-align: center;
    }
    
    footer {
      margin-top: auto;
      display: flex;
      gap: 24px;
      padding: 20px 0;
    }
    
    footer a {
      transition: opacity 0.2s;
    }
    
    footer a:hover {
      opacity: 0.7;
    }
    
    footer svg {
      fill: #fafafa;
      width: 28px;
      height: 28px;
    }
    
    .hidden { 
      display: none !important;
    }
    
    #nft-preview-container {
      margin-top: 10px;
      margin-bottom: 10px;
      width: 100%; 
      max-width: 390px; 
      background: #000;
      border: 2px solid #49dfb5;
      border-radius: 10px;
      display: flex;
      justify-content: center; 
      align-items: center;
      padding: 0; 
      position: relative; 
      max-height: 60vh;
      overflow: hidden;
    }

    #nft-preview-container svg {
      display: block;
      width: 100%;
      height: auto;
      max-height: 60vh;
      margin: 0 auto;
    }

    #nft-preview-container img {
      display: block;
      width: 100%;
      height: auto;
      max-height: 60vh;
      margin: 0 auto;
    }

    .sparkles::before {
      content: "";
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: radial-gradient(circle, white 2px, transparent 2px);
      background-size: 20px 20px;
      pointer-events: none;
      opacity: 0.7;
      animation: sparkle 6s linear infinite; 
      z-index: 10; 
    }

    @keyframes sparkle {
      0% { background-position: 0 0; opacity: 0.6; }
      50% { background-position: 10px 10px; opacity: 1; }
      100% { background-position: 0 0; opacity: 0.6; }
    }

    .common.sparkles::before {
      background: radial-gradient(circle, #bbb 1.5px, transparent 2px); 
      animation-duration: 6s;
    }
    
    .rare.sparkles::before {
      background: radial-gradient(circle, #2196f3 2.5px, transparent 2px); 
      animation-duration: 4s;
    }
    
    .legendary.sparkles::before {
      background: radial-gradient(circle, gold 3.5px, transparent 2px);
      animation-duration: 2s; 
    }
    
    .mythic.sparkles::before {
      background: radial-gradient(circle, crimson 4px, transparent 2px);
      animation-duration: 1.5s; 
    }

    .spinner {
      border: 2px solid #fff3;
      border-top: 2px solid #fff;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: inline-block;
      animation: spin 0.6s linear infinite;
    }
    
    @keyframes spin { 
      100% { transform: rotate(360deg); } 
    }
  </style>
</head>
<body>

  <!-- Live CELOUSD chart -->
  <div class="tradingview-widget-container" role="img" aria-label="Live CELO Price Chart">
    <div id="celo-chart"></div>
    <script src="https://s3.tradingview.com/tv.js"></script>
    <script>
      new TradingView.widget({
        autosize: true,
        symbol: "BINANCE:CELOUSDT",
        interval: "60",
        theme: "dark",
        style: "1",
        hide_top_toolbar: true,
        withdateranges: false,
        toolbar_bg: "#1f1f1f",
        locale: "en",
        enable_publishing: false,
        allow_symbol_change: false,
        container_id: "celo-chart"
      });
    </script>
  </div>

  <h1>Mint Your Celo Price NFT</h1>

  <!-- User Address -->
  <div id="userAddressBox" class="addresses-box hidden"></div>
  
  <!-- Total Minted -->
  <div id="totalSupply" class="status-box status-warning"></div>
  
  <!-- Wallet Connect Button (for non-Farcaster users) -->
  <button class="action-button" id="connectBtn" style="display: none;">Connect Wallet</button>
  
  <!-- Mint Button -->
  <button class="action-button" id="mintBtn">MINT</button>
  
  <!-- Preview Button -->
  <button class="action-button preview-button hidden" id="previewBtn">Preview NFT</button>

  <!-- Status Box -->
  <div id="statusBox" class="status-box" aria-live="polite"></div>

  <!-- NFT SVG Preview -->
  <div id="nft-preview-container" class="hidden"></div>

  <!-- Footer -->
  <footer>
    <a href="https://farcaster.xyz/dare1.eth" target="_blank" rel="noopener noreferrer" aria-label="Farcaster">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8z"/><path d="M12 7c-2.757 0-5 2.243-5 5s2.243 5 5 5 5-2.243 5-5-2.243-5-5-5zm0 8c-1.654 0-3-1.346-3-3s1.346-3 3-3 3 1.346 3 3-1.346 3-3 3z"/></svg>
    </a>
    <a href="https://x.com/kumar14700" target="_blank" rel="noopener noreferrer" aria-label="Twitter">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 16 16"><path d="M12.6.75h2.454l-5.36 6.142L16 15.25h-4.937l-3.867-5.07-4.425 5.07H.316l5.733-6.57L0 .75h5.063l3.495 4.633L12.601.75Zm-.86 13.028h1.36L4.323 2.145H2.865l8.875 11.633Z"/></svg>
    </a>
  </footer>

  <!-- Farcaster SDK -->
  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk@0.2.2';
    
    (async () => {
      try {
        await sdk.actions.ready({ disableNativeGestures: true });
        console.log('Farcaster SDK initialized');
      } catch (e) {
        console.log('Farcaster SDK not available:', e);
      }
    })();
  </script>

  <!-- Main App Logic with Reown AppKit -->
  <script type="module">
    import {
      createConfig,
      connect,
      disconnect,
      getAccount,
      watchAccount,
      writeContract,
      readContract,
      waitForTransactionReceipt,
      http
    } from 'https://esm.sh/@wagmi/core@2.13.4';
    import { celo } from 'https://esm.sh/@wagmi/core@2.13.4/chains';
    import { injected } from 'https://esm.sh/@wagmi/core@2.13.4/connectors';
    import { farcasterMiniApp } from 'https://esm.sh/@farcaster/miniapp-wagmi-connector@0.2.2';
    import { createAppKit } from 'https://esm.sh/@reown/appkit@1.1.2';
    import { WagmiAdapter } from 'https://esm.sh/@reown/appkit-adapter-wagmi@1.1.2';

    // Configuration
    const MAX_SUPPLY_FUNCTION_NAME = 'maxSupply';
    const PROJECT_ID = 'e0dd881bad824ac3418617434a79f917';

    // DOM Elements
    const statusBox = document.getElementById('statusBox');
    const supplyBox = document.getElementById('totalSupply');
    const mintBtn = document.getElementById('mintBtn');
    const previewBtn = document.getElementById('previewBtn');
    const connectBtn = document.getElementById('connectBtn');
    const userAddrBox = document.getElementById('userAddressBox');
    const previewContainer = document.getElementById('nft-preview-container');
    const ALL_RARITY_CLASSES = ["common", "rare", "legendary", "mythic"];

    let MAX_SUPPLY = 0;
    let lastMintedTokenId = null;
    let contractAddress = null;
    let mintPriceWei = 0n;
    let userAddress = null;
    let contractDetails = null;
    let modal = null;
    let isFarcasterEnvironment = false;
    let wagmiConfig = null;

    // Helper Functions
    function setStatus(msg, type = 'info') {
      statusBox.innerHTML = '';
      let icon = '';
      if (type === 'success') icon = '✅ ';
      else if (type === 'error') icon = '❌ ';
      else if (type === 'warning') icon = '⚠️ ';
      else if (type === 'info') icon = 'ℹ️ ';
      
      statusBox.className = `status-box status-${type}`;
      statusBox.insertAdjacentText('afterbegin', icon + msg);
    }
    
    function showAddress(addr) {
      const shortAddr = `${addr.slice(0, 6)}...${addr.slice(-4)}`;
      userAddrBox.textContent = `Your address: ${shortAddr}`;
      userAddrBox.classList.remove('hidden');
      connectBtn.style.display = 'none';
      mintBtn.style.display = 'flex';
    }

    function showConnectButton() {
      connectBtn.style.display = 'flex';
      mintBtn.style.display = 'none';
      userAddrBox.classList.add('hidden');
    }

    async function fetchCeloPrice() {
      try {
        const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=celo&vs_currencies=usd');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        if (!data || !data.celo || !data.celo.usd) {
          throw new Error("Invalid response structure from CoinGecko.");
        }
        return data.celo.usd;
      } catch (e) {
        console.error("Failed to fetch CELO price:", e);
        throw new Error("Failed to fetch CELO price. Please try again.");
      }
    }

    function adjustInjectedSvg(container) {
      const svg = container.querySelector('svg');
      if (svg) {
        if (!svg.hasAttribute('viewBox')) {
          const w = svg.getAttribute('width');
          const h = svg.getAttribute('height');
          if (w && h) {
            const W = parseFloat(w);
            const H = parseFloat(h);
            if (!isNaN(W) && !isNaN(H) && W > 0 && H > 0) {
              svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
            }
          }
        }
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        svg.removeAttribute('width');
        svg.removeAttribute('height');
        svg.style.width = '100%';
        svg.style.height = 'auto';
        svg.style.maxHeight = '60vh';
        svg.style.display = 'block';
      } else {
        const img = container.querySelector('img');
        if (img) {
          img.style.width = '100%';
          img.style.height = 'auto';
          img.style.maxHeight = '60vh';
          img.style.display = 'block';
        }
      }
      container.style.maxHeight = '60vh';
    }

    async function updateSupply(initialLoad = false) {
      if (initialLoad) {
        supplyBox.innerHTML = '<span class="spinner"></span> Loading supply...';
      }

      try {
        if (!initialLoad) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }

        const total = await readContract(wagmiConfig, {
          address: contractDetails.address,
          abi: contractDetails.abi,
          functionName: 'totalSupply'
        });

        const totalNumber = Number(total);

        if (MAX_SUPPLY > 0) {
          supplyBox.textContent = `Minted: ${totalNumber}/${MAX_SUPPLY}`;

          if (totalNumber >= MAX_SUPPLY) {
            mintBtn.disabled = true;
            mintBtn.innerText = "SOLD OUT";
            mintBtn.title = "The maximum supply has been reached.";
            supplyBox.className = "status-box status-error";
            
            if (!initialLoad) {
              setStatus(`All ${MAX_SUPPLY} NFTs have been minted!`, "warning");
            }
          } else if (!initialLoad) {
            mintBtn.disabled = false;
            const celoPrice = Number(mintPriceWei) / 1e18;
            mintBtn.innerText = mintPriceWei > 0n ? `MINT (${celoPrice.toFixed(4)} CELO)` : 'MINT';
            mintBtn.title = '';
            supplyBox.className = "status-box status-warning";
          }
        } else {
          supplyBox.textContent = `Total Minted: ${totalNumber}`;
          supplyBox.className = "status-box status-info";
          
          if (!initialLoad) {
            mintBtn.disabled = false;
            const celoPrice = Number(mintPriceWei) / 1e18;
            mintBtn.innerText = mintPriceWei > 0n ? `MINT (${celoPrice.toFixed(4)} CELO)` : 'MINT';
          }
        }

        return total;
      } catch (e) {
        supplyBox.textContent = "Total Minted: N/A";
        console.error('Error updating supply:', e);
        return 0;
      }
    }

    async function previewNft(tokenId) {
      if (!contractDetails) return;

      statusBox.innerHTML = '';
      statusBox.className = 'status-box';
      
      previewBtn.disabled = true;
      previewBtn.innerHTML = '<span class="spinner"></span> Loading Preview…';
      previewContainer.classList.add('hidden');
      previewContainer.innerHTML = '';
      previewContainer.classList.remove("sparkles", ...ALL_RARITY_CLASSES);

      try {
        const tokenURI = await readContract(wagmiConfig, {
          address: contractAddress,
          abi: contractDetails.abi,
          functionName: 'tokenURI',
          args: [BigInt(tokenId)] 
        });

        const base64Json = tokenURI.split(',')[1];
        if (!base64Json) throw new Error("Invalid tokenURI format.");

        const jsonString = atob(decodeURIComponent(base64Json));
        const metadata = JSON.parse(jsonString);
        
        const base64Svg = metadata.image.split(',')[1];
        if (!base64Svg) throw new Error("Invalid image data format.");

        let svgString = atob(decodeURIComponent(base64Svg));
        const safeSvg = svgString.replace(/<script.*?>.*?<\/script>/g, '');

        previewContainer.innerHTML = safeSvg;
        previewContainer.classList.remove('hidden');
        adjustInjectedSvg(previewContainer);
        
        let rarityText = "Common";
        let priceText = "N/A";

        if (metadata.attributes) {
          const rarityAttr = metadata.attributes.find(attr => attr.trait_type === 'Rarity');
          const priceAttr = metadata.attributes.find(attr => attr.trait_type === 'CELO Price Snapshot');
          
          if (rarityAttr) rarityText = rarityAttr.value;
          if (priceAttr) priceText = priceAttr.value;
        }
        
        previewContainer.classList.add("sparkles");
        const rarityClassLower = rarityText.toLowerCase();
        previewContainer.classList.add(rarityClassLower);

        const buttonLabel = `Preview NFT #${tokenId} (${rarityText} / $${priceText})`;
        previewBtn.innerText = buttonLabel;

      } catch (e) {
        setStatus("Failed to load NFT preview. Check console for details.", 'error'); 
        previewBtn.innerText = 'Preview NFT Error';
        console.error(`NFT Preview Error for token ID ${tokenId}:`, e);
        previewContainer.classList.add('hidden');
      } finally {
        previewBtn.disabled = false;
      }
    }

    // Setup Wagmi Config with Reown AppKit
    const wagmiAdapter = new WagmiAdapter({
      networks: [celo],
      projectId: PROJECT_ID,
      ssr: false
    });

    wagmiConfig = wagmiAdapter.wagmiConfig;

    // Initialize App
    (async () => {
      try {
        // Load last minted token from sessionStorage (not localStorage to avoid cross-session issues)
        lastMintedTokenId = sessionStorage.getItem("lastMintedTokenId");
        if (lastMintedTokenId) {
          previewBtn.innerText = `Preview NFT #${lastMintedTokenId}`;
          previewBtn.classList.remove('hidden');
        }

        // Check if running in Farcaster environment
        try {
          if (typeof sdk !== 'undefined' && sdk.context) {
            isFarcasterEnvironment = true;
            console.log('Running in Farcaster environment');
          }
        } catch (e) {
          console.log('Not in Farcaster environment:', e);
        }

        // Try Farcaster connection first
        let connected = false;
        if (isFarcasterEnvironment) {
          try {
            const farcasterConnector = wagmiConfig.connectors.find(c => c.id === 'farcasterMiniApp');
            if (farcasterConnector) {
              const conn = await connect(wagmiConfig, { connector: farcasterConnector });
              userAddress = conn.accounts[0];
              showAddress(userAddress);
              connected = true;
              console.log('Connected via Farcaster:', userAddress);
              
              // Prompt to add mini app
              const hasPromptedAddApp = sessionStorage.getItem('hasPromptedAddApp');
              if (!hasPromptedAddApp && sdk?.actions?.addMiniApp) {
                try {
                  await sdk.actions.addMiniApp();
                  sessionStorage.setItem('hasPromptedAddApp', 'true');
                } catch(e) {
                  console.log('Add mini app prompt declined or failed:', e);
                }
              }
            }
          } catch (e) {
            console.log('Farcaster connection failed:', e);
          }
        }

        // If not connected via Farcaster, setup Reown AppKit
        if (!connected) {
          modal = createAppKit({
            adapters: [wagmiAdapter],
            networks: [celo],
            projectId: PROJECT_ID,
            features: {
              analytics: true,
              email: false,
              socials: [],
              connectMethodsOrder: ['wallet']
            },
            allWallets: 'SHOW',
            themeMode: 'dark',
            themeVariables: {
              '--w3m-accent': '#49dfb5'
            }
          });

          // Check if already connected
          const currentAccount = getAccount(wagmiConfig);
          if (currentAccount.isConnected && currentAccount.address) {
            userAddress = currentAccount.address;
            showAddress(userAddress);
            connected = true;
            console.log('Already connected:', userAddress);
          } else {
            // Show connect button for non-Farcaster users
            showConnectButton();
            setStatus('Connect your wallet to mint NFTs', 'info');
          }
        }

        // If still not connected, don't proceed with contract setup
        if (!connected && !isFarcasterEnvironment) {
          mintBtn.disabled = true;
          return;
        }

        // Load contract details
        try {
          contractDetails = await fetch('./contract.json').then(r => r.json());
          contractAddress = contractDetails.address;
          console.log('Contract loaded:', contractAddress);
        } catch (e) { 
          setStatus("Missing contract details. Ensure 'contract.json' is deployed.", 'error'); 
          console.error('Contract load error:', e); 
          mintBtn.disabled = true; 
          return;
        }

        if (!contractDetails) {
          mintBtn.disabled = true;
          return;
        }

        // Get chain ID
        const currentAccount = getAccount(wagmiConfig);
        const chainId = currentAccount.chainId;

        // Network guard
        if (chainId && chainId !== celo.id) {
          setStatus("Please switch to Celo Mainnet.", 'warning');
          mintBtn.disabled = true;
          mintBtn.title = "Switch to Celo Mainnet to mint.";
          return;
        } else {
          mintBtn.title = ""; 
        }
        
        // Fetch contract settings
        try {
          const [max, price] = await Promise.all([
            readContract(wagmiConfig, {
              address: contractDetails.address,
              abi: contractDetails.abi,
              functionName: MAX_SUPPLY_FUNCTION_NAME
            }),
            readContract(wagmiConfig, {
              address: contractDetails.address,
              abi: contractDetails.abi,
              functionName: 'mintPrice'
            })
          ]);
          MAX_SUPPLY = Number(max);
          mintPriceWei = BigInt(price);
          
          if (mintPriceWei > 0n) {
            const celoPrice = Number(mintPriceWei) / 1e18;
            mintBtn.innerText = `MINT (${celoPrice.toFixed(4)} CELO)`;
          }

          console.log('Contract settings:', { MAX_SUPPLY, mintPriceWei: mintPriceWei.toString() });

        } catch (e) {
          setStatus(`Could not read contract settings. Assuming unlimited/free.`, 'warning');
          MAX_SUPPLY = 0;
          mintPriceWei = 0n;
          console.warn(`Failed to read contract settings.`, e);
        }

        // Fetch total supply
        if (connected) {
          await updateSupply(true);
        }
      } catch (error) {
        console.error('Initialization error:', error);
        setStatus('Failed to initialize. Please refresh the page.', 'error');
      }
    })();

    // Watch for account changes
    watchAccount(wagmiConfig, {
      onChange(account) {
        try {
          if (account.address && account.isConnected) {
            console.log('Account changed to:', account.address);
            userAddress = account.address;
            showAddress(userAddress);
            setStatus('Account connected.', 'info');
            mintBtn.disabled = false;
            
            updateSupply(true);
            previewBtn.classList.add('hidden');
            previewContainer.classList.add('hidden');
            sessionStorage.removeItem('lastMintedTokenId');
            lastMintedTokenId = null;

          } else if (!account.isConnected && userAddress) {
            console.log('Wallet disconnected');
            userAddress = null;
            userAddrBox.classList.add('hidden');
            showConnectButton();
            setStatus('Wallet disconnected. Please connect again.', 'warning');
            mintBtn.disabled = true;
            
            previewBtn.classList.add('hidden');
            previewContainer.classList.add('hidden');
            supplyBox.textContent = 'Connect wallet to see supply';
            sessionStorage.removeItem('lastMintedTokenId');
            lastMintedTokenId = null;
          }
        } catch (error) {
          console.error('Account change error:', error);
        }
      },
    });

    // Connect Button Handler
    connectBtn.addEventListener('click', async () => {
      try {
        if (modal) {
          modal.open();
        }
      } catch (error) {
        console.error('Connect button error:', error);
        setStatus('Failed to open wallet modal.', 'error');
      }
    });

    // Mint Button Handler
    mintBtn.addEventListener('click', async () => {
      try {
        if (!contractDetails) {
          setStatus("Contract details are missing. Cannot mint.", "error");
          return;
        }

        if (mintBtn.disabled && mintBtn.innerText === "SOLD OUT") {
          setStatus("This NFT drop is sold out.", "warning");
          return;
        }
        
        statusBox.innerHTML = '';
        statusBox.className = 'status-box';

        previewBtn.classList.add('hidden');
        previewContainer.classList.add('hidden');
        previewContainer.classList.remove('sparkles', ...ALL_RARITY_CLASSES);

        mintBtn.disabled = true;
        mintBtn.innerHTML = '<span class="spinner"></span> Minting...';
        lastMintedTokenId = null;

        const { address, abi } = contractDetails;

        const currentSupply = await readContract(wagmiConfig, {
          address,
          abi,
          functionName: 'totalSupply'
        });
        
        const nextTokenId = Number(currentSupply) + 1;

        const price = await fetchCeloPrice();
        const priceForContract = Math.floor(price * 10000);

        const hash = await writeContract(wagmiConfig, {
          address,
          abi,
          functionName: 'mint',
          args: [priceForContract],
          value: mintPriceWei 
        });
        
        setStatus("Confirming transaction...", "info");
        const receipt = await waitForTransactionReceipt(wagmiConfig, { hash });

        if (receipt.status === 'reverted') {
          throw new Error('Transaction was reverted.');
        }

        sessionStorage.setItem('lastMintedTokenId', nextTokenId.toString());
        setStatus("Mint Successful! ", "success");
        
        if (contractAddress) {
          const celoscanTokenUrl = `https://celoscan.io/token/${contractAddress}?a=${nextTokenId}`;
          const celoscanTxUrl = `https://celoscan.io/tx/${hash}`;

          const txLink = document.createElement('a');
          txLink.href = celoscanTxUrl;
          txLink.target = '_blank';
          txLink.rel = 'noopener noreferrer';
          txLink.textContent = 'View Tx';
          txLink.style.cssText = 'color:#fff;text-decoration:underline;margin-left:8px;';

          const tokenLink = document.createElement('a');
          tokenLink.href = celoscanTokenUrl;
          tokenLink.target = '_blank';
          tokenLink.rel = 'noopener noreferrer';
          tokenLink.textContent = 'View on Celoscan';
          tokenLink.style.cssText = 'color:#fff;text-decoration:underline;margin-left:8px;';

          statusBox.appendChild(txLink);
          statusBox.insertAdjacentText('beforeend', ' | ');
          statusBox.appendChild(tokenLink);
        }

        lastMintedTokenId = nextTokenId;

        await updateSupply();
        previewBtn.classList.remove('hidden');
        previewBtn.innerText = `Preview NFT #${nextTokenId}`;
        await previewNft(lastMintedTokenId);

      } catch (e) {
        let errorMsg = e.shortMessage || "Mint failed.";
        
        if (e.message && (e.message.includes("Invalid parameters were provided to the RPC method") || e.message.includes("RPC"))) {
          errorMsg = "Mint failed due to a connection error. Please reload/refresh the miniapp and try again.";
        } else if (e.message && e.message.includes("User rejected")) {
          errorMsg = "Transaction was rejected.";
        } else if (!e.shortMessage) {
          errorMsg = "Mint failed. This may be caused by a stale connection. Please reload/refresh the miniapp and try again.";
        }
        
        setStatus(errorMsg, "error");
        console.error('Mint Error:', e);
        
        previewBtn.classList.add('hidden');
        previewContainer.classList.add('hidden');
        previewContainer.classList.remove('sparkles', ...ALL_RARITY_CLASSES);
        sessionStorage.removeItem('lastMintedTokenId');
        lastMintedTokenId = null;
      } finally {
        if (mintBtn.innerText !== "SOLD OUT") {
          mintBtn.disabled = false;
          const celoPrice = Number(mintPriceWei) / 1e18;
          mintBtn.innerText = mintPriceWei > 0n ? `MINT (${celoPrice.toFixed(4)} CELO)` : 'MINT';
        }
      }
    });

    // Preview Button Handler
    previewBtn.addEventListener('click', async () => {
      try {
        if (lastMintedTokenId !== null) {
          await previewNft(lastMintedTokenId);
        } else {
          setStatus("No token ID to preview. Please mint first.", 'warning');
        }
      } catch (error) {
        console.error('Preview error:', error);
        setStatus('Failed to load preview.', 'error');
      }
    });

  </script>
</body>
</html>
